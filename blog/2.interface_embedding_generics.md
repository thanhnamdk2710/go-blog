# Understanding Interface, Embedding, and Generics

Go was designed to be simple, readable, and highly scalable. But three language features - interface, embedding, and generics - unlock real power when building large backend services.

These features help you:

- Write cleaner and more modular code
- Reduce duplication
- Build flexible and reusable components
- Improve testability
- Implement clean architecture patterns
- Design domain-driven systems

In this article, we break down each one with practical examples you can apply directly in your Go projects.

## 1. Interface - Behavior over Structure

Go interfaces define behavior, not data structure. This fits perfectly with principles like Dependency Inversion, "Program to an interface, not an implementation."

Basic Interface

```go
type Notifier interface {
    Send(subject, message string) error
}
```

Any struct implementing this method is automatically part of the `Notifier` interface - no explicit keyword needed.

### Example: Email & SMS Notification

```go
type EmailService struct{}

func (EmailService) Send(subject, message string) error {
    fmt.Println("Sending email:", subject, message)
    return nil
}

type SMSService struct{}

func (SMSService) Send(subject, message string) error {
    fmt.Println("Sending SMS:", subject, message)
    return nil
}
```

Now your business logic becomes decoupled:

```go
func NotifyUser(n Notifier, content string) {
    err := n.Send("Notification", content)
    if err != nil {
        fmt.Println("Error sending notification:", err)
    }
}
```

Use it:

```go
func main() {
    email := EmailService{}
    NotifyUser(email, "Email service")

    sms := SMSService{}
    NotifyUser(sms, "SMS service")
}
```

Why it's powerful

- Plug-and-play behavior
- Testing becomes easy (mock your interface)
- Swap implementations without changing core logic
- Cleaner layering (Domain → Ports → Adapters)

## 2. Embedding - Composition Over Inheritance

Go has no classical inheritance. Instead, it provides embedding to reuse behavior while keeping the code flexible.

Basic Embedding

```go
type Logger struct{}

func (Logger) Log(msg string) {
    fmt.Println("[INFO]", msg)
}
```

Embed it in services:

```go
type UserService struct {
    Logger
}

func (s UserService) CreateUser(name string) {
    s.Log("Creating user: " + name)
}
```

### Example: Repository Embedding

Many projects use a base repository:

```go
type BaseRepo struct {
    db *sql.DB
}

func (b BaseRepo) Exec(query string, args ...any) error {
    _, err := b.db.Exec(query, args...)
    return err
}
```

Embed it:

```go
type UserRepo struct {
    BaseRepo
}

func (ur UserRepo) CreateUser(name string) error {
    return ur.Exec("INSERT INTO users(name) VALUES($1)", name)
}
```

Why embedding helps

- No inheritance hierarchy
- Compose behavior only where needed
- Reduces boilerplate code
- Increases readability
- Keeps your design flexible

## 3. Generics - Type Safety Without Duplication

Generics were introduced in Go 1.18, giving developers the ability to write reusable and type-safe components.

Before generics

```go
func MapString(items []string, fn func(string) string) []string { ... }
func MapInt(items []int, fn func(int) int) []int { ... }
```

Too much duplication.

After generics

```go
func Map[T any](items []T, fn func(T) T) []T {
    result := make([]T, len(items))
    for i, v := range items {
        result[i] = fn(v)
    }
    return result
}
```

### Example: Generic Repository Response

Backend services often reuse pagination responses:

Before generics:

```go
type UserPagination struct {
    Total int
    Items []User
}

type OrderPagination struct {
    Total int
    Items []Order
}
```

With generics:

```go
type Pagination[T any] struct {
    Total int
    Items []T
}
```

Use it:

```go
users := Pagination[User]{Total: 100, Items: userList}
orders := Pagination[Order]{Total: 50, Items: orderList}
```

Generic constraints example

```go
type ID interface {
    ~int | ~string
}

func FilterByID[T any](items []T, getID func(T) ID, target ID) []T {
    var result []T
    for _, item := range items {
        if getID(item) == target {
            result = append(result, item)
        }
    }
    return result
}
```

## Using All Three Together in a Clean Architecture

A common pattern in large Go services:

### Domain: define behavior via interfaces

```go
type UserRepository interface {
    Create(User) error
    FindByID(string) (User, error)
}
```

### Infrastructure: implement using embedding

```go
type SQLRepo struct {
    BaseRepo
}

func (r SQLRepo) Create(user User) error {
    return r.Exec("INSERT INTO users...", ...)
}
```

### Application layer: use generics for reuse

```go
type Service[T any] struct {
    repo interface {
        Create(T) error
    }
}
```

Now you have:

- Clean separation
- Reusable components
- Swappable implementations
- Strong type safety

## Example: Event Handler with All Three

Imagine we have multiple event types: UserCreated, OrderPaid, InventoryUpdated.

### 1. Define a generic event handler

```go
type EventHandler[T any] interface {
    Handle(T) error
}
```

### 2. Use embedding for shared logger

```go
type HandlerBase struct {
    Logger
}
```

### 3. Implement type-specific handlers

```go
// UserCreated event
type UserCreatedEvent struct {
    UserID string
}

type UserCreatedHandler struct {
    HandlerBase
}

func (h UserCreatedHandler) Handle(e UserCreatedEvent) error {
    h.Log("Handling UserCreated event for user: " + e.UserID)
    return nil
}

// OrderPaid event
type OrderPaidEvent struct {
    OrderID string
}

type OrderPaidHandler struct {
    HandlerBase
}

func (h OrderPaidHandler) Handle(e OrderPaidEvent) error {
    h.Log("Handling OrderPaid event for order: " + e.OrderID)
    return nil
}

// InventoryUpdated
type InventoryUpdatedEvent struct {
    SKU string
    Qty int
}

type InventoryUpdatedHandler struct {
    HandlerBase
}

func (h InventoryUpdatedHandler) Handle(e InventoryUpdatedEvent) error {
    h.Log(fmt.Sprintf("Handling InventoryUpdated event for SKU %s with qty %d", e.SKU, e.Qty))
    return nil
}
```

### 4. Reusable dispatcher using generics

```go
type Dispatcher[T any] struct {
    handler EventHandler[T]
}

func (d Dispatcher[T]) Dispatch(event T) error {
    return d.handler.Handle(event)
}
```

### 5. Using the Dispatcher

```go
func main() {
    // UserCreatedEvent
    userDispatcher := Dispatcher[UserCreatedEvent]{
        handler: &UserCreatedHandler{},
    }
    userDispatcher.Dispatch(UserCreatedEvent{UserID: "123"})

    // OrderPaidEvent
    orderDispatcher := Dispatcher[OrderPaidEvent]{
        handler: &OrderPaidHandler{},
    }
    orderDispatcher.Dispatch(OrderPaidEvent{OrderID: "234"})

    // InventoryUpdatedEvent
    inventoryDispatcher := Dispatcher[InventoryUpdatedEvent]{
        handler: &InventoryUpdatedHandler{},
    }
    inventoryDispatcher.Dispatch(InventoryUpdatedEvent{SKU: "SKU-001", Qty: 10})
}
```

Now the system supports any event type without code duplication.

## Final Thoughts

Interfaces, embedding, and generics are not isolated features.
They form a powerful trio that enables:

- Clean Architecture
- Domain-Driven Design
- Reusable services
- Extensible microservices
- Highly testable code
- Less duplication and boilerplate

Mastering these three features will make you a significantly stronger Go engineer, especially when building large-scale backend systems.
