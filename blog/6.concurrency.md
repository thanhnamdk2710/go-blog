# Mastering Concurrency

Go's concurrency model - goroutines, channel, and synchronization primitives - allows developers to build high-performance and scalable backend systems. But writing correct and efficient concurrent code requires understanding the right patterns.

In this article, we explore six fundamental concurrency patterns used in Go systems:

- Fan-Out / Fan-In
- Pipeline Pattern
- Select Pattern
- Mutex
- RWMutex
- Atomic Operations

These patterns form the backbone of production systems such as Kafka consumers, ETL pipelines, HTTP workers, caching layers, metric collectors, and more.

## Fan-Out / Fan-In

When to use

- Distribute workload to multiple workers
- Increase throughput
- Run tasks in parallel
- CPU-heavy or IO-heavy operations

"Fan-Out" starts multiple goroutines to perform work.
"Fan-In" merges their results back into one channel.

### Example: Fetch User Profiles from External APIs in Parallel

```go
func fetchUser(id int) string {
    time.Sleep(100 * time.Millisecond) // simulate API call
    return fmt.Sprintf("User %d", id)
}

func main() {
    ids := []int{1, 2, 3, 4, 5}

    jobs := make(chan int)
    results := make(chan string)

    // Fan-out: start 3 workers
    for w := 1; w <= 3; w++ {
        go func() {
            for id := range jobs {
                results <- fetchUser(id)
            }
        }()
    }

    // Send jobs
    go func() {
        for _, id := range ids {
            jobs <- id
        }
        close(jobs)
    }()

    // Fan-in: collect results
    for range ids {
        fmt.Println(<-results)
    }
}
```

Benefits

- Efficient parallelization
- Bounded concurrency
- Works well with worker pools

## Pipeline Pattern

When to use

- Stream data through multiple processing stages
- Combine transformations
- Build modular ETL or event processing systems

A pipeline is a series of stages connected by channels.

```txt
Source → Stage A → Stage B → Stage C → Output
```

Each stage does one thing and passes results down the chain.

### Example: ETL Pipeline (Extract → Transform → Load)

```go
// Stage 1: extract
func extract(nums []int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

// Stage 2: transform
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

// Stage 3: load
func printAll(in <-chan int) {
    for v := range in {
        fmt.Println(v)
    }
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    pipeline := square(extract(nums))
    printAll(pipeline)
}
```

Why pipelines matter

- Decomposed, testable stages
- Easier to parallelize
- Natural backpressure handling
