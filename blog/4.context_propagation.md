# Proper Context Propagation

If you're building backend systems - REST APIs, gRPC services, Kafka consumers, database layers - context propagation is one of the most important skills you must master.

Yet many applications misuse `context.Context`:

- Passing `context.Background()` everywhere
- Ignoring cancellation
- Forgetting deadlines
- Losing metadata across layers
- Causing goroutine leaks
- Not handling request timeouts
- Using `context` as a "data dump"

This article explains how to propagate context correctly, why it matters, and how to apply it in a production system.

## 1. What is Context?

`context.Context` carries request-scoped data, including:

- Cancellation signals
- Deadlines (timeouts)
- Metadata (request ID, auth token, tenant, language...)
- Trace IDs for distributed tracing
- Logging fields

Context is designed to flow from the top of the call chain downward.

## 2. The rules of Proper Context Propagation

Google's Go team defines strict rules:

### Rule 1: Always pass context as the first argument

Incorrect:

```go
func GetUser(id string, ctx context.Context) // wrong order
```

Correct

```go
func (s *UserService) GetUser(ctx context.Context, id string) (User, error)
```

### Rule 2: Never store context in a struct

Context is request-scoped; storing it breaks lifecycle management.

Incorrect:

```go
type Service struct {
    ctx context.Context // do not store
}
```

Correct:

```go
func (s *Service) Process(ctx context.Context) error
```

### Rule 3: Do not create new backgrounds inside request flow

```go
ctx := context.Background() // destroys cancellation chain
```

Correct way:

```go
// Receive ctx from caller and propagate downward
return s.repo.FindUser(ctx, id)
```

### Rule 4: Use context for control signals, not business data

Good:

- request ID
- auth token
- deadline
- tracing metadata

Bad:

- user object
- config values
- huge JSON payload
- database models

## 3. Use Case: HTTP Request → Service → Repository → External API

HTTP Layer (entrypoint)

```go
func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context() // extract ctx from request

    id := r.URL.Query().Get("id")
    user, err := h.service.GetUser(ctx, id)
    // ...
}
```

Service Layer

```go
func (s *UserService) GetUser(ctx context.Context, id string) (User, error) {
    ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
    defer cancel()

    return s.repo.FindByID(ctx, id)
}
```

Repository Layer

```go
func (r *UserRepo) FindByID(ctx context.Context, id string) (User, error) {
    query := "SELECT id, name FROM users WHERE id = $1"
    row := r.db.QueryRowContext(ctx, query, id)
    // ...
}
```

Why this is correct:

- Timeout flows across all layers
- DB call is canceled if HTTP request is canceled
- No goroutine leak
- Clean propagation of metadata
- Infrastructure (DB, cache, gRPC) gets the same cancellation signal

## 4. Adding Metadata (Request ID, Auth Token)

### Step 1: Create context keys (unexpected to avoid collision)

```go
type contextKey string

const (
    keyRequestID = contextKey("request_id")
    keyAuthToken = contextKey("auth_token")
)
```

### Step 2: Store metadata inside context

```go
ctx = context.WithValue(ctx, keyRequestID, reqID)
```

### Step 3: Retrieve later anywhere in the request chain

```go
reqID := ctx.Value(keyRequestID).(string)
```

## 5. gRPC Example (Correct Way)

Incoming request:

```go
func (s *UserGRPCService) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    user, err := s.appService.GetUser(ctx, req.Id)
    // ...
}
```

gRPC frameworks automatically propagate:

- tracing context
- headers
- deadlines

Just don't overwrite them with `context.Background()`.

## 6. Kafka Consumer Example (Easy to Misuse)

Kafka messages are not request-bound, so they don't come with HTTP context. But you still need:

- deadlines
- cancellation
- tracing per message

Correct:

```go
for msg := range messages {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    go func() {
        defer cancel()
        s.ProcessMessage(ctx, msg)
    }()
}
```

Incorrect (the deadly pattern):

```go
go s.ProcessMessage(context.Background(), msg) // no timeout, no tracking
```

## 7. Avoiding Goroutine Leaks

Incorrect:

```go
go func() {
    // long-running job
}()
```

Correct:

```go
go func(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return
        default:
            // work
        }
    }
}(ctx)
```

This stops goroutines when:

- HTTP request is canceled
- gRPC client disconnects
- Shutdown signal received

## 8. Example: S3 Upload with Timeout + RequestID

```go
func (s *FileService) UploadFile(ctx context.Context, file []byte) error {
    ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
    defer cancel()

    requestID, ok := ctx.Value(keyRequestID).(string)
    if !ok {
        requestID = "unknown"
    }

    s.logger.Info("upload started", zap.String("requestID", requestID))

    _, err := s.s3.PutObjectWithContext(ctx, &s3.PutObjectInput{
        Bucket: aws.String("uploads"),
        Key:    aws.String(requestID + ".bin"),
        Body:   bytes.NewReader(file),
    })
    if err != nil {
        return fmt.Errorf("upload file: %w", err)
    }

    return nil
}
```

If the client cancels the request → S3 upload stops immediately.

## 9. Final Thoughts

Proper context propagation enables:

- Graceful cancellation
- Deadline enforcement
- Reliable request tracking
- Clean microservice communication
- Zero goroutine leaks
- Better observability
- Predictable system behavior

Mastering context is essential if you're building microservices with:

- HTTP APIs
- gRPC services
- Kafka consumers
- S3 uploads
- PostgreSQL queries
- Redis caching
