# Struct Design in Go: Value vs Pointer, Zero-Value, and Receiver Types

Designing structs correctly is one of the core skills every backend engineer must master. While struct model appears simple, decisions around value vs pointer semantics, zero-value behavior, and method receiver types have a major impact on readability, performance, memory safety, and API correctness.

In this article, we break down the principles and patterns used in production systems.

## 1. Value vs Pointer Semantics

Go lets you work with structs either as values or pointers:

```go
type User struct {
    ID   int
    Name string
}
```

You can create:

```go
u1 := User{ID: 1}  // value
u2 := &User{ID: 2} // pointer
```

Understanding the difference is essential.

### When to Use Value Types

- You want to immutable-like behavior. Passing copies protects against unexpected modification.
  Example: request models, DTOs, event payloads.
- The struct is small (typicall < 64bytes). Copying tiny structs is cheap
- The struct represents a simple data container. Configuration options, coordinates, math objects.

### When to Use Pointer Types

- The struct is large. Avoid expensive copying of big structs.
- You need to mutable fields in methods or functions. Mutation requires shared reference.
- You want to express optional values. `Nil` represents "absence".

Example:

```go
type Cache struct {
    store map[string]string
}
var c *Cache = nil // safe to express no cache
```
