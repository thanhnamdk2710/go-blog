# Mastering Error Handling

Error handling is one of the most critical parts of backend development. In Go, error handling is explicit and predictable - no try/catch magic, no hidden exceptions.

But to build production-grade services, you need more than just:

```go
if err != nil {
    return err
}
```

You need to understand Sentinel Errors, Error Wrapping, and Stack Traces. These techniques help you create clearer, safer, and more debuggable systems - especially when working with microservices, databases, and external APIs.

This article breaks down each concept with practical examples that you can apply immediately.

## 1. Sentinel Errors

**What they are**

A Sentinel Error is a predefined, exported, reusable error value. It represents a specific known error case.

```go
var ErrUserNotFound = errors.New("user not found")
```

Use case:

- Domain validation
- Business rules
- Repository layer
- Consistent error checking across services

Example: User Repository

```go
var ErrUserNotFound = errors.New("user not found")

func (r UserRepo) FindByID(id string) (*User, error) {
    row := r.db.QueryRow("SELECT id, name FROM users WHERE id=$1", id)

    var u User
    if err := row.Scan(&u.ID, &u.Name); err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, ErrUserNotFound
        }
        return nil, err
    }
    return &u, nil
}
```

Service layer:

```go
user, err := repo.FindByID("123")
if errors.Is(err, ErrUserNotFound) {
    return http.StatusNotFound, "User does not exist"
}
```

Why this is good:

- Consistency
- Predictable logic flow
- Clean if-else trees
- Works well with error wrapping

## 2. Error Wrapping

**Why wrapping matters**

Raw errors lose context. For example:

```bash
# bash
"connection refused"
"timeout"
"EOF"
```

Not useful.

Go's `%w` wrap operator

```go
return fmt.Errorf("updating user: %w", err)
```

Now you preserve:

- Context
- Original error
- Ability to check with `errors.Is`

Example: Service → Repository → Database

```go
func (s UserService) UpdateUser(u User) error {
    if err := s.repo.Update(u); err != nil {
        return fmt.Errorf("service update user: %w", err)
    }
    return nil
}
```

Repository layer:

```go
func (r UserRepo) Update(u User) error {
    _, err := r.db.Exec("UPDATE users SET name=$1 WHERE id=$2", u.Name, u.ID)
    if err != nil {
        return fmt.Errorf("repo update user: %w", err)
    }
    return nil
}
```

Now you get a traceable chain:

```bash
# bash
service update user: repo update user: SQL error: connection refused
```

Much clearer than only:

```bash
# bash
connection refused
```

## 3. Checking Wrapped Errors

Go provides two key functions:

`errors.Is` check if an error is or wraps another error.

```go
if errors.Is(err, ErrUserNotFound) { ... }
```

`errors.As` extract a specific underlying error type

```go
var netErr net.Error
if errors.As(err, &netErr) && netErr.Timeout() {
    fmt.Println("network timeout!")
}
```

This is essential for microservices that deal with:

- network errors
- database errors
- third-party API errors
- custom error types

## 4. Stack Traces - Essential for Production Debugging

Go's built-in `error` type does not include stack traces by default. But stack traces are extremely important in production environments.

Popular solutions:

- `github.com/pkg/errors`
- `go.uber.org/zap` + custom fields
- `sentry-go` or `newrelic`
- `runtime/debug` for panic tracing

### Example Using `pkg/errors`

```go
import "github.com/pkg/errors"

func processPayment() error {
    return errors.Wrap(err, "payment failed")
}
```

View stack trace:

```go
payment failed: underlying DB error
main.processPayment
    /app/payment.go:42
main.handleRequest
    /app/handler.go:88
runtime.goexit
```

### Example Using `runtime/debug.Stack()`

```go
func riskyOperation() error {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("panic:", r)
            fmt.Println(string(debug.Stack()))
        }
    }()
    // ...
}
```

## 5. Example (Kafka + PostgreSQL)

Imagine a service that consumes Kafka messages and stores them in PostgreSQL.

Step 1: Sentinel Errors

```go
var ErrInvalidMessage = errors.New("invalid data format")
```

Step 2: Validate message

```go
if msg.UserID == "" {
    return fmt.Errorf("validate event: %w", ErrInvalidMessage)
}
```

Step 3: Store in DB

```go
func (r Repo) Save(msg Event) error {
    _, err := r.db.Exec("INSERT INTO logs ...")
    if err != nil {
        return fmt.Errorf("db save event: %w", err)
    }
    return nil
}
```

Step 4: Kafka consumer handles everything

```go
if errors.Is(err, ErrInvalidMessage) {
    metrics.Inc("invalid_message")
    return nil // skip but do not retry
}

log.Error("failed to process message", zap.Error(err))
return err // retry or commit later
```

Benefits:

- Clear separation of logic
- Meaningful observability
- Easy to debug
- Safe retry behavior
- Cleaner logs

## 6. Final Thoughts

Error handling is intentionally explicit.
When used properly - with sentinel errors, wrapping, and stack traces - you gain:

- Cleaner code
- More predictable control flow
- Better observability
- Faster debugging
- Safer production behavior

These patterns are essential for any engineer building scalable microservices.
